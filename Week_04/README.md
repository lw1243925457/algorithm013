# 学习笔记
***
## 作业
### 1.使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方
&ensp;&ensp;&ensp;&ensp;半有序的具体情况是啥？第一种情况是由有序数组旋转一次导致的半有序；第二种情况是在有序的数组的基础上左右随机添加元素导致半有序，如[5, 8, 9, 1, 2, 3, 4, 2]

&ensp;&ensp;&ensp;&ensp;针对第一种情况，由有序数组旋转一次导致的半有序数组，查找中间无序的部分，如[4, 5, 6, 7, 0, 1, 2]，无序的部分应该就是【7,0】

&ensp;&ensp;&ensp;&ensp;解题思路：无序部分的特点是两边序列分别递增和递减，如7为无序部分，4-7为递增，7-2为递减，当7的下一位符合递减时即为答案

&ensp;&ensp;&ensp;&ensp;解题细化思路大致入下，这里假设半有序数组由递增数组选中得到,无返回表示数组全部有序：

- 1.初始化左右指针
- 2.左右相加除以2得到中间位置
- 3.判断左指针与中间指针下标值大小
	- 1.如果左指针小于中间，且中间指针下移+1的位置下标值小于中间指针下值，则无序部分已找到；如果不小于则更新左指针为中间指针+1，跳转到2步骤
	- 2.如果左指针大于中间，且中间指针下移-1的位置下标值大于中间指针下值，则无序部分已找到；如果不大于则更新右指针为中间指针-1，跳转到2步骤

&ensp;&ensp;&ensp;&ensp;特殊情况无序部分处于首尾：[3, 4, 5, 2], [7, 0, 1, 2]，上面的思路能正常处理

&ensp;&ensp;&ensp;&ensp;伪代码如下：

```python
def digitFind(nums)
	n = len(nums)
	l, r = 0, n-1
	while l < r:
		mid = (l + r) // 2
		if nums[l] < nums[mid]:
			if nums[mid] > nums[mid+1]:
				return [mid, mid+1]
			l = mid + 1
		else:
			if nums[mid] < nums[mid-1]:
				return [mid-1, mid]
			r = mid - 1
	return []
```

## 做题感想总结
&ensp;&ensp;&ensp;&ensp;中等的动态规划、贪心之类的题目做着有些吃力，但还能做，但困难难度的就大部分做不了

&ensp;&ensp;&ensp;&ensp;感觉还是做的太少了，这方面的题目是弱项，得针对性多练练